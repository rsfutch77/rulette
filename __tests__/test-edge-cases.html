<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edge Cases and Error Handling Test</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            margin: 0; 
            padding: 20px; 
            background: #f5f5f5; 
            padding-bottom: 200px; /* Space for fixed bottom bar */
        }
        .main-container { 
            display: flex; 
            gap: 20px; 
            max-width: 1600px; 
            margin: 0 auto; 
        }
        .test-column {
            flex: 1;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            height: calc(100vh - 280px); /* Account for top padding and bottom results bar */
            overflow-y: auto;
        }
        .instructions-column {
            flex: 1;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-left: 4px solid #dc3545;
            height: calc(100vh - 280px); /* Account for top padding and bottom results bar */
            overflow-y: auto;
        }
        
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .test-section h2 {
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
            margin-top: 0;
        }
        
        .test-section h3 {
            color: #495057;
            margin: 15px 0 10px 0;
            font-size: 16px;
        }
        
        .test-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 3px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            display: block;
            width: 100%;
            text-align: left;
            margin-bottom: 5px;
        }
        
        .test-button:hover {
            background: #0056b3;
        }
        
        .test-button.danger {
            background: #dc3545;
        }
        
        .test-button.danger:hover {
            background: #c82333;
        }
        
        .test-button.warning {
            background: #ffc107;
            color: #212529;
        }
        
        .test-button.warning:hover {
            background: #e0a800;
        }
        
        /* Fixed bottom results bar */
        #test-results {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: #343a40;
            color: white;
            padding: 15px;
            max-height: 180px;
            overflow-y: auto;
            border-top: 3px solid #dc3545;
            z-index: 1000;
        }
        #test-results h4 {
            margin: 0 0 10px 0;
            color: #ffc107;
        }
        #results-content {
            font-size: 12px;
            line-height: 1.4;
        }
        #results-content div {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px solid #495057;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-ready { background: #28a745; }
        .status-error { background: #dc3545; }
        .status-warning { background: #ffc107; }
        
        .system-status {
            background: #e9ecef;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .instruction-step {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 12px;
            margin: 10px 0;
            border-left: 4px solid #dc3545;
        }
        .instruction-step.setup { border-left-color: #007bff; }
        .instruction-step.deck { border-left-color: #28a745; }
        .instruction-step.turn { border-left-color: #ffc107; }
        .instruction-step.disconnect { border-left-color: #fd7e14; }
        .instruction-step.system { border-left-color: #dc3545; }
        .instruction-step.manual { border-left-color: #6c757d; }
        
        .step-number {
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            margin-right: 8px;
        }
        .step-title {
            font-weight: bold;
            color: #495057;
            margin-bottom: 5px;
        }
        .step-description {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 8px;
        }
        .step-expected {
            font-size: 12px;
            color: #28a745;
            font-style: italic;
        }
        
        h1, h2, h3 {
            color: #343a40;
        }
        
        .phase-header {
            background: linear-gradient(135deg, #dc3545, #c82333);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            margin: 20px 0 10px 0;
            font-weight: bold;
        }
        
        .category-header {
            background: #6c757d;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            margin: 15px 0 8px 0;
            font-size: 14px;
            font-weight: bold;
        }
        
        .test-category {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 15px;
            margin: 10px 0;
            background: #f8f9fa;
        }
        
        .danger-warning {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 13px;
        }
        
        .info-box {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Test Controls Column -->
        <div class="test-column">
            <h1>Edge Cases and Error Handling Test Suite</h1>
            <p>This page tests comprehensive error handling for the wheel spin and card draw logic.</p>
            
            <!-- Initialize Controls at Top -->
            <div class="test-section">
                <h3>Test Setup</h3>
                <button class="test-button" data-action="initializeTestSession">Initialize Test Session</button>
                <button class="test-button" data-action="resetTestEnvironment">Reset Test Environment</button>
                <button class="test-button" data-action="clearResults">Clear Results</button>
                <button class="test-button" data-action="runAllTests">🚀 Run All Tests</button>
            </div>
            
            <!-- System Status -->
            <div class="system-status">
                <h3>System Status</h3>
                <div id="system-status">
                    <div><span class="status-indicator status-error"></span>Game Manager: <span id="game-manager-status">Not Loaded</span></div>
                    <div><span class="status-indicator status-error"></span>Card Manager: <span id="card-manager-status">Not Loaded</span></div>
                    <div><span class="status-indicator status-error"></span>Wheel Component: <span id="wheel-status">Not Loaded</span></div>
                </div>
            </div>
            
            <!-- Edge Case Tests -->
            <div class="test-section">
                <h2>Edge Case Tests</h2>
                
                <div class="test-category">
                    <h3>1. Empty Deck Handling</h3>
                    <button class="test-button" data-action="testEmptyDeck">1.1 Test Empty Deck</button>
                    <button class="test-button" data-action="testEmptyDeckWithReshuffle">1.2 Test Empty Deck with Reshuffle</button>
                </div>
                
                <div class="test-category">
                    <h3>2. Rule Restrictions</h3>
                    <button class="test-button warning" data-action="testRuleRestrictions">2.1 Test Rule-Based Restrictions</button>
                    <button class="test-button" data-action="testInvalidDeckType">2.2 Test Invalid Deck Type</button>
                </div>
                
                <div class="test-category">
                    <h3>3. Turn Management Violations</h3>
                    <button class="test-button danger" data-action="testOutOfTurnAction">3.1 Test Out-of-Turn Action</button>
                    <button class="test-button danger" data-action="testDuplicateAction">3.2 Test Duplicate Action</button>
                    <button class="test-button danger" data-action="testInvalidPlayer">3.3 Test Invalid Player</button>
                </div>
                
                <div class="test-category">
                    <h3>4. Player Disconnection</h3>
                    <button class="test-button warning" data-action="testPlayerDisconnectDuringTurn">4.1 Test Disconnect During Turn</button>
                    <button class="test-button warning" data-action="testPlayerDisconnectNotTurn">4.2 Test Disconnect Not During Turn</button>
                    <button class="test-button danger" data-action="testAllPlayersDisconnect">4.3 Test All Players Disconnect</button>
                </div>
                
                <div class="test-category">
                    <h3>5. System Errors</h3>
                    <button class="test-button danger" data-action="testMissingComponents">5.1 Test Missing Components</button>
                    <button class="test-button danger" data-action="testInvalidSession">5.2 Test Invalid Session</button>
                    <button class="test-button danger" data-action="testCorruptedGameState">5.3 Test Corrupted Game State</button>
                </div>
            </div>
            
        </div>
        
        <!-- Instructions Column -->
        <div class="instructions-column">
            <h2>🧪 Edge Case Testing Guide</h2>
            
            <div class="info-box">
                <strong>Purpose:</strong> This test suite validates error handling and edge cases in the game system. Tests are designed to fail gracefully and provide meaningful error messages.
            </div>
            
            <div class="phase-header">Setup Phase</div>
            
            <div class="instruction-step setup">
                <div class="step-title">
                    <span class="step-number">🔧</span>Initialize Test Session (Recommended First)
                </div>
                <div class="step-description">
                    Sets up a complete test environment with players, sessions, and turn order
                </div>
                <div class="step-expected">
                    ✅ Creates test session with 3 players and proper game state
                </div>
            </div>
            
            <div class="phase-header">Category 1: Empty Deck Handling</div>
            
            <div class="instruction-step deck">
                <div class="step-title">
                    <span class="step-number">1.1</span>Test Empty Deck
                </div>
                <div class="step-description">
                    Tests behavior when trying to draw from a completely empty deck
                </div>
                <div class="step-expected">
                    ❌ Should fail with "No cards available" error message
                </div>
            </div>
            
            <div class="instruction-step deck">
                <div class="step-title">
                    <span class="step-number">1.2</span>Test Empty Deck with Reshuffle
                </div>
                <div class="step-description">
                    Tests automatic reshuffle mechanism when deck is empty but discard pile has cards
                </div>
                <div class="step-expected">
                    ✅ Should successfully reshuffle and draw the same card again
                </div>
            </div>
            
            <div class="phase-header">Category 2: Rule Restrictions</div>
            
            <div class="instruction-step deck">
                <div class="step-title">
                    <span class="step-number">2.1</span>Test Rule-Based Restrictions
                </div>
                <div class="step-description">
                    Tests game rules that prevent drawing from certain decks under specific conditions
                </div>
                <div class="step-expected">
                    ❌ Should fail with "deck is restricted" error message
                </div>
            </div>
            
            <div class="instruction-step deck">
                <div class="step-title">
                    <span class="step-number">2.2</span>Test Invalid Deck Type
                </div>
                <div class="step-description">
                    Tests behavior when trying to draw from a non-existent deck
                </div>
                <div class="step-expected">
                    ❌ Should fail with "deck does not exist" error message
                </div>
            </div>
            
            <div class="phase-header">Category 3: Turn Management Violations</div>
            
            <div class="danger-warning">
                <strong>⚠️ Warning:</strong> These tests intentionally violate turn order rules to verify proper error handling.
            </div>
            
            <div class="instruction-step turn">
                <div class="step-title">
                    <span class="step-number">3.1</span>Test Out-of-Turn Action
                </div>
                <div class="step-description">
                    Tests when a player tries to act when it's not their turn
                </div>
                <div class="step-expected">
                    ❌ Should fail with "NOT_PLAYER_TURN" error code
                </div>
            </div>
            
            <div class="instruction-step turn">
                <div class="step-title">
                    <span class="step-number">3.2</span>Test Duplicate Action
                </div>
                <div class="step-description">
                    Tests when current player tries to spin twice in the same turn
                </div>
                <div class="step-expected">
                    ❌ Should fail with "NOT_PLAYER_TURN" error (already spun)
                </div>
            </div>
            
            <div class="instruction-step turn">
                <div class="step-title">
                    <span class="step-number">3.3</span>Test Invalid Player
                </div>
                <div class="step-description">
                    Tests behavior when a non-existent player tries to take action
                </div>
                <div class="step-expected">
                    ❌ Should fail with "PLAYER_NOT_FOUND" error code
                </div>
            </div>
            
            <div class="phase-header">Category 4: Player Disconnection</div>
            
            <div class="instruction-step disconnect">
                <div class="step-title">
                    <span class="step-number">4.1</span>Test Disconnect During Turn
                </div>
                <div class="step-description">
                    Tests handling when the current player disconnects mid-turn
                </div>
                <div class="step-expected">
                    ✅ Should advance to next player and mark disconnection
                </div>
            </div>
            
            <div class="instruction-step disconnect">
                <div class="step-title">
                    <span class="step-number">4.2</span>Test Disconnect Not During Turn
                </div>
                <div class="step-description">
                    Tests handling when a non-current player disconnects
                </div>
                <div class="step-expected">
                    ✅ Should mark player as disconnected without affecting turn order
                </div>
            </div>
            
            <div class="instruction-step disconnect">
                <div class="step-title">
                    <span class="step-number">4.3</span>Test All Players Disconnect
                </div>
                <div class="step-description">
                    Tests session cleanup when all players have disconnected
                </div>
                <div class="step-expected">
                    ✅ Should clean up empty session and return true
                </div>
            </div>
            
            <div class="phase-header">Category 5: System Errors</div>
            
            <div class="danger-warning">
                <strong>⚠️ Critical:</strong> These tests simulate system failures and component unavailability.
            </div>
            
            <div class="instruction-step system">
                <div class="step-title">
                    <span class="step-number">5.1</span>Test Missing Components
                </div>
                <div class="step-description">
                    Tests behavior when required system components are unavailable
                </div>
                <div class="step-expected">
                    ❌ Should handle gracefully with appropriate error messages
                </div>
            </div>
            
            <div class="instruction-step system">
                <div class="step-title">
                    <span class="step-number">5.2</span>Test Invalid Session
                </div>
                <div class="step-description">
                    Tests behavior when trying to act on a non-existent game session
                </div>
                <div class="step-expected">
                    ❌ Should fail with "SESSION_NOT_FOUND" error code
                </div>
            </div>
            
            <div class="instruction-step system">
                <div class="step-title">
                    <span class="step-number">5.3</span>Test Corrupted Game State
                </div>
                <div class="step-description">
                    Tests recovery from corrupted or incomplete game state data
                </div>
                <div class="step-expected">
                    ❌ Should fail with "TURN_NOT_INITIALIZED" error code
                </div>
            </div>
            
            <div class="phase-header">Manual Controls & Automation</div>
            
            <div class="instruction-step manual">
                <div class="step-title">
                    <span class="step-number">🚀</span>Run All Tests (Automated)
                </div>
                <div class="step-description">
                    Executes all edge case tests automatically with 500ms delays between tests
                </div>
                <div class="step-expected">
                    🏁 Comprehensive test suite completion with full results
                </div>
            </div>
            
            
            <div style="margin-top: 30px; padding: 15px; background: #e9ecef; border-radius: 5px;">
                <h4>🎯 What to Watch For:</h4>
                <ul style="margin: 10px 0; padding-left: 20px; font-size: 13px;">
                    <li><strong style="color: #28a745;">✅ Success:</strong> Expected behavior, proper error handling</li>
                    <li><strong style="color: #dc3545;">❌ Failure:</strong> Unexpected errors or missing validation</li>
                    <li><strong style="color: #ffc107;">⚠️ Warning:</strong> Edge cases that need attention</li>
                    <li><strong>Error Codes:</strong> Specific validation failure reasons</li>
                    <li><strong>System Status:</strong> Component availability indicators</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Fixed Bottom Results Bar -->
    <div id="test-results">
        <h4>🔍 Test Results (Live Updates)</h4>
        <div id="results-content">Test results will appear here...</div>
    </div>

    <script type="module">
        import { gameManager } from '../gameManager.js';
        import { CardManager } from '../cardManager.js';
        import { loadCardData } from '../cardModels.js';
        import { WheelComponent } from '../wheelComponent.js';
        
        let testSessionId = 'test-session-edge-cases';
        let testPlayers = ['player1', 'player2', 'player3'];
        let cardManager;
        let wheelComponent;
        
        // Initialize components
        async function initializeComponents() {
            try {
                // Initialize card manager
                const cardData = await loadCardData();
                cardManager = new CardManager(cardData);
                window.cardManager = cardManager;
                updateStatus('card-manager-status', 'Ready', 'ready');
                
                // Initialize wheel component
                wheelComponent = new WheelComponent();
                window.wheelComponent = wheelComponent;
                updateStatus('wheel-status', 'Ready', 'ready');
                
                // Game manager should already be available
                if (gameManager) {
                    updateStatus('game-manager-status', 'Ready', 'ready');
                }
                
                log('✅ All components initialized successfully');
                
            } catch (error) {
                log('❌ Failed to initialize components: ' + error.message);
                console.error('Initialization error:', error);
            }
        }
        
        function updateStatus(elementId, text, status) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = text;
                const indicator = element.parentElement.querySelector('.status-indicator');
                if (indicator) {
                    indicator.className = `status-indicator status-${status}`;
                }
            }
        }
        
        function log(message) {
            const results = document.getElementById('results-content');
            const timestamp = new Date().toLocaleTimeString();
            const icon = message.startsWith('✅') ? '✅' : message.startsWith('❌') ? '❌' : message.startsWith('⚠️') ? '⚠️' : '🧪';
            
            // Create a new div for this message
            const messageDiv = document.createElement('div');
            messageDiv.textContent = `${icon} [${timestamp}] ${message}`;
            
            results.appendChild(messageDiv);
            
            // Keep only last 15 messages
            while (results.children.length > 15) {
                results.removeChild(results.firstChild);
            }
            
            results.scrollTop = results.scrollHeight;
            console.log(message);
        }
        
        // Test Functions
        window.testEmptyDeck = function() {
            log('🧪 Testing empty deck handling...');
            try {
                const emptyCardManager = new CardManager({ emptyDeck: [] });
                const result = emptyCardManager.safeDraw('emptyDeck', 'test-player', {});
                log(`Empty deck result: ${JSON.stringify(result)}`);
                
                // FIXME: Test was checking for "No cards" but actual error message is "No cards available"
                if (!result.success && result.error.includes('No cards available')) {
                    log('✅ Empty deck properly handled');
                } else {
                    log('❌ Empty deck not properly handled - Expected error with "No cards available", got: ' + JSON.stringify(result));
                }
            } catch (error) {
                log('❌ Error testing empty deck: ' + error.message);
            }
        };
        
        window.testEmptyDeckWithReshuffle = function() {
            log('🧪 Testing empty deck with discard pile...');
            try {
                const testCardManager = new CardManager({ testDeck: [{ id: 'test-card', name: 'Test Card' }] });
                
                // Draw the only card
                const firstDraw = testCardManager.draw('testDeck');
                log(`First draw: ${firstDraw.name}`);
                
                // Discard it
                testCardManager.discard('testDeck', firstDraw);
                log('Card discarded');
                
                // Try to draw again (should reshuffle)
                const secondDraw = testCardManager.draw('testDeck');
                log(`Second draw after reshuffle: ${secondDraw.name}`);
                
                if (secondDraw.name === firstDraw.name) {
                    log('✅ Reshuffle mechanism working correctly');
                } else {
                    log('❌ Reshuffle mechanism failed');
                }
            } catch (error) {
                log('❌ Error testing reshuffle: ' + error.message);
            }
        };
        
        window.testRuleRestrictions = function() {
            log('🧪 Testing rule-based restrictions...');
            try {
                if (!cardManager) {
                    log('❌ Card manager not available');
                    return;
                }
                
                // FIXME: Need to use an existing deck type for restriction test
                // First create a test deck, then restrict it
                const testCardManager = new CardManager({ testDeck: [{ id: 'test-card', name: 'Test Card' }] });
                const gameState = { restrictedDecks: ['testDeck'] };
                const result = testCardManager.safeDraw('testDeck', 'test-player', gameState);
                log(`Restricted deck result: ${JSON.stringify(result)}`);
                
                if (!result.success && result.error.includes('restricted')) {
                    log('✅ Rule restrictions properly enforced');
                } else {
                    log('❌ Rule restrictions not working');
                }
            } catch (error) {
                log('❌ Error testing rule restrictions: ' + error.message);
            }
        };
        
        window.testInvalidDeckType = function() {
            log('🧪 Testing invalid deck type...');
            try {
                if (!cardManager) {
                    log('❌ Card manager not available');
                    return;
                }
                
                const result = cardManager.safeDraw('nonexistentDeck', 'test-player', {});
                log(`Invalid deck result: ${JSON.stringify(result)}`);
                
                if (!result.success && result.error.includes('does not exist')) {
                    log('✅ Invalid deck type properly handled');
                } else {
                    log('❌ Invalid deck type not properly handled');
                }
            } catch (error) {
                log('❌ Error testing invalid deck: ' + error.message);
            }
        };
        
        window.testOutOfTurnAction = function() {
            log('🧪 Testing out-of-turn action...');
            try {
                if (!gameManager) {
                    log('❌ Game manager not available');
                    return;
                }
                
                // Initialize a test session
                gameManager.initializeTurnOrder(testSessionId, testPlayers);
                
                // Try to act as wrong player
                const wrongPlayer = testPlayers[1]; // Not the first player
                const validation = gameManager.validatePlayerAction(testSessionId, wrongPlayer, 'spin');
                log(`Out-of-turn validation: ${JSON.stringify(validation)}`);
                
                if (!validation.valid && validation.errorCode === 'NOT_PLAYER_TURN') {
                    log('✅ Out-of-turn action properly blocked');
                } else {
                    log('❌ Out-of-turn action not properly blocked');
                }
            } catch (error) {
                log('❌ Error testing out-of-turn action: ' + error.message);
            }
        };
        
        window.testDuplicateAction = function() {
            log('🧪 Testing duplicate action...');
            try {
                if (!gameManager) {
                    log('❌ Game manager not available');
                    return;
                }
                
                // Initialize test session
                gameManager.initializeTurnOrder(testSessionId, testPlayers);
                const currentPlayer = gameManager.getCurrentPlayer(testSessionId);
                
                // Record first spin
                gameManager.recordPlayerSpin(testSessionId, currentPlayer);
                log('First spin recorded');
                
                // Try to spin again
                const validation = gameManager.validatePlayerAction(testSessionId, currentPlayer, 'spin');
                log(`Duplicate action validation: ${JSON.stringify(validation)}`);
                
                if (!validation.valid && validation.errorCode === 'NOT_PLAYER_TURN') {
                    log('✅ Duplicate action properly blocked');
                } else {
                    log('❌ Duplicate action not properly blocked');
                }
            } catch (error) {
                log('❌ Error testing duplicate action: ' + error.message);
            }
        };
        
        window.testInvalidPlayer = function() {
            log('🧪 Testing invalid player...');
            try {
                if (!gameManager) {
                    log('❌ Game manager not available');
                    return;
                }
                
                const validation = gameManager.validatePlayerAction(testSessionId, 'nonexistent-player', 'spin');
                log(`Invalid player validation: ${JSON.stringify(validation)}`);
                
                if (!validation.valid && validation.errorCode === 'PLAYER_NOT_FOUND') {
                    log('✅ Invalid player properly handled');
                } else {
                    log('❌ Invalid player not properly handled');
                }
            } catch (error) {
                log('❌ Error testing invalid player: ' + error.message);
            }
        };
        
        window.testPlayerDisconnectDuringTurn = function() {
            log('🧪 Testing player disconnect during turn...');
            try {
                if (!gameManager) {
                    log('❌ Game manager not available');
                    return;
                }
                
                // Initialize test session with players
                gameManager.initializeTurnOrder(testSessionId, testPlayers);
                
                // Initialize players
                testPlayers.forEach(playerId => {
                    gameManager.players[playerId] = {
                        playerId,
                        displayName: `Player ${playerId}`,
                        points: 20,
                        status: 'active',
                        hasRefereeCard: false,
                        hand: []
                    };
                });
                
                const currentPlayer = gameManager.getCurrentPlayer(testSessionId);
                log(`Current player: ${currentPlayer}`);
                
                // Simulate disconnect
                const result = gameManager.handlePlayerDisconnect(testSessionId, currentPlayer);
                log(`Disconnect result: ${JSON.stringify(result)}`);
                
                if (result.handled && result.nextPlayer) {
                    log('✅ Player disconnect during turn properly handled');
                } else {
                    log('❌ Player disconnect during turn not properly handled');
                }
            } catch (error) {
                log('❌ Error testing player disconnect: ' + error.message);
            }
        };
        
        window.testPlayerDisconnectNotTurn = function() {
            log('🧪 Testing player disconnect not during turn...');
            try {
                if (!gameManager) {
                    log('❌ Game manager not available');
                    return;
                }
                
                // Initialize test session
                gameManager.initializeTurnOrder(testSessionId, testPlayers);
                
                // Initialize players
                testPlayers.forEach(playerId => {
                    gameManager.players[playerId] = {
                        playerId,
                        displayName: `Player ${playerId}`,
                        points: 20,
                        status: 'active',
                        hasRefereeCard: false,
                        hand: []
                    };
                });
                
                const notCurrentPlayer = testPlayers[1]; // Not the current player
                
                // Simulate disconnect
                const result = gameManager.handlePlayerDisconnect(testSessionId, notCurrentPlayer);
                log(`Disconnect result: ${JSON.stringify(result)}`);
                
                if (result.handled && !result.nextPlayer) {
                    log('✅ Player disconnect not during turn properly handled');
                } else {
                    log('❌ Player disconnect not during turn not properly handled');
                }
            } catch (error) {
                log('❌ Error testing player disconnect: ' + error.message);
            }
        };
        
        window.testAllPlayersDisconnect = function() {
            log('🧪 Testing all players disconnect...');
            try {
                if (!gameManager) {
                    log('❌ Game manager not available');
                    return;
                }
                
                // Initialize test session
                gameManager.initializeTurnOrder(testSessionId, testPlayers);
                
                // Initialize players
                testPlayers.forEach(playerId => {
                    gameManager.players[playerId] = {
                        playerId,
                        displayName: `Player ${playerId}`,
                        points: 20,
                        status: 'active',
                        hasRefereeCard: false,
                        hand: []
                    };
                });
                
                // Disconnect all players
                testPlayers.forEach(playerId => {
                    gameManager.players[playerId].status = 'disconnected';
                });
                
                // Check if session gets cleaned up
                const cleaned = gameManager.cleanupEmptySession(testSessionId);
                log(`Session cleanup result: ${cleaned}`);
                
                if (cleaned) {
                    log('✅ Empty session properly cleaned up');
                } else {
                    log('❌ Empty session not properly cleaned up');
                }
            } catch (error) {
                log('❌ Error testing all players disconnect: ' + error.message);
            }
        };
        
        window.testMissingComponents = function() {
            log('🧪 Testing missing components...');
            try {
                // Temporarily remove components
                const originalCardManager = window.cardManager;
                const originalGameManager = window.gameManager;
                
                window.cardManager = null;
                
                // Test card draw with missing card manager
                if (window.drawCardWithErrorHandling) {
                    const result = window.drawCardWithErrorHandling('deckType1', 'test-player', testSessionId);
                    log(`Missing card manager result: ${JSON.stringify(result)}`);
                }
                
                // Restore components
                window.cardManager = originalCardManager;
                
                log('✅ Missing components test completed');
            } catch (error) {
                log('❌ Error testing missing components: ' + error.message);
            }
        };
        
        window.testInvalidSession = function() {
            log('🧪 Testing invalid session...');
            try {
                if (!gameManager) {
                    log('❌ Game manager not available');
                    return;
                }
                
                const validation = gameManager.validatePlayerAction('invalid-session', 'test-player', 'spin');
                log(`Invalid session validation: ${JSON.stringify(validation)}`);
                
                if (!validation.valid && validation.errorCode === 'SESSION_NOT_FOUND') {
                    log('✅ Invalid session properly handled');
                } else {
                    log('❌ Invalid session not properly handled');
                }
            } catch (error) {
                log('❌ Error testing invalid session: ' + error.message);
            }
        };
        
        window.testCorruptedGameState = function() {
            log('🧪 Testing corrupted game state...');
            try {
                if (!gameManager) {
                    log('❌ Game manager not available');
                    return;
                }
                
                // Create a session with corrupted turn data
                gameManager.gameSessions[testSessionId] = { sessionId: testSessionId };
                gameManager.currentTurn[testSessionId] = null; // Corrupted turn data
                
                const validation = gameManager.validatePlayerAction(testSessionId, 'test-player', 'spin');
                log(`Corrupted state validation: ${JSON.stringify(validation)}`);
                
                if (!validation.valid && validation.errorCode === 'TURN_NOT_INITIALIZED') {
                    log('✅ Corrupted game state properly handled');
                } else {
                    log('❌ Corrupted game state not properly handled');
                }
            } catch (error) {
                log('❌ Error testing corrupted game state: ' + error.message);
            }
        };
        
        window.initializeTestSession = function() {
            log('🔧 Initializing test session...');
            try {
                if (!gameManager) {
                    log('❌ Game manager not available');
                    return;
                }
                
                // Create session
                gameManager.gameSessions[testSessionId] = {
                    sessionId: testSessionId,
                    hostId: testPlayers[0],
                    players: testPlayers,
                    status: 'in-progress',
                    referee: testPlayers[0]
                };
                
                // Initialize players
                testPlayers.forEach(playerId => {
                    gameManager.players[playerId] = {
                        playerId,
                        displayName: `Player ${playerId}`,
                        points: 20,
                        status: 'active',
                        hasRefereeCard: playerId === testPlayers[0],
                        hand: []
                    };
                });
                
                // Initialize turn order
                gameManager.initializeTurnOrder(testSessionId, testPlayers);
                
                log('✅ Test session initialized successfully');
            } catch (error) {
                log('❌ Error initializing test session: ' + error.message);
            }
        };
        
        window.resetTestEnvironment = function() {
            log('🔄 Resetting test environment...');
            try {
                if (gameManager) {
                    delete gameManager.gameSessions[testSessionId];
                    delete gameManager.currentTurn[testSessionId];
                    delete gameManager.turnOrder[testSessionId];
                    
                    testPlayers.forEach(playerId => {
                        delete gameManager.players[playerId];
                    });
                }
                
                log('✅ Test environment reset');
            } catch (error) {
                log('❌ Error resetting test environment: ' + error.message);
            }
        };
        
        window.clearResults = function() {
            document.getElementById('results-content').innerHTML = 'Test results will appear here...';
        };
        
        
        window.runAllTests = function() {
            log('🚀 Running all edge case tests...');
            clearResults();
            
            const tests = [
                testEmptyDeck,
                testEmptyDeckWithReshuffle,
                testRuleRestrictions,
                testInvalidDeckType,
                testOutOfTurnAction,
                testDuplicateAction,
                testInvalidPlayer,
                testPlayerDisconnectDuringTurn,
                testPlayerDisconnectNotTurn,
                testAllPlayersDisconnect,
                testMissingComponents,
                testInvalidSession,
                testCorruptedGameState
            ];
            
            let testIndex = 0;
            function runNextTest() {
                if (testIndex < tests.length) {
                    try {
                        tests[testIndex]();
                    } catch (error) {
                        log(`❌ Test ${testIndex + 1} failed: ${error.message}`);
                    }
                    testIndex++;
                    setTimeout(runNextTest, 500); // Small delay between tests
                } else {
                    log('🏁 All tests completed');
                }
            }
            
            runNextTest();
        };
        
        // Add event listeners for all test buttons
        function setupButtonEventListeners() {
            const buttons = document.querySelectorAll('button[data-action]');
            buttons.forEach(button => {
                button.addEventListener('click', (event) => {
                    const action = event.target.getAttribute('data-action');
                    if (action && typeof window[action] === 'function') {
                        window[action]();
                    } else {
                        console.error(`Function ${action} not found or not callable`);
                    }
                });
            });
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            initializeComponents();
            setupButtonEventListeners();
        });
        
    </script>

<script>
window.testCompletionSignal = {
    completed: false,
    timestamp: null,
    results: null
};

function markTestComplete(results = null) {
    window.testCompletionSignal.completed = true;
    window.testCompletionSignal.timestamp = new Date().toISOString();
    window.testCompletionSignal.results = results;
    console.log('TEST_COMPLETION_SIGNAL:', JSON.stringify(window.testCompletionSignal));
    
    document.body.style.border = '5px solid #28a745';
    document.body.style.backgroundColor = '#f8fff8';
    
    const banner = document.createElement('div');
    banner.innerHTML = '✅ TEST COMPLETED - Ready for next test';
    banner.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0;
        background: #28a745; color: white; padding: 15px;
        text-align: center; font-weight: bold; z-index: 9999;
    `;
    document.body.appendChild(banner);
}

const completionButton = document.createElement('button');
completionButton.innerHTML = '🏁 Mark Test Complete';
completionButton.style.cssText = `
    position: fixed; bottom: 20px; right: 20px;
    background: #28a745; color: white; border: none;
    padding: 15px 25px; border-radius: 5px;
    font-size: 16px; font-weight: bold; cursor: pointer; z-index: 9999;
`;
completionButton.onclick = () => markTestComplete();
document.body.appendChild(completionButton);
</script>
</body>
</html>